## 📘 Throughput Optimization

이번에는 성능 정의 중 2번째인 처리량에 대해 알아보겠습니다.

처리량이란 **주어진 기간에 완성되는 작업의 수**를 뜻합니다, 보통 처리량은 시간 단위 / 초 단위로 작업을 나눠 측정합니다.

<br>

- 처리량 향상을 위한 2가지 접근법
- Thread Pooling

---
## 📘 어플리케이션의 처리량 개선 방법

하나의 작업을 완수하는데 T의 시간이 걸리면 이룰수 있는 최소 처리량은 1/T 가 됩니다.

작업은 하위 Task로 나눌 수 있다면 T/N의 최대 처리량을 얻을 수 있습니다.

<br>

하지만, 하위 Task로 작업을 나누더라도 T/N 보다 낮은 처리량을 얻을 확률도 높습니다.

**지연 시간을 최적화 할 때와 같은 단점**을 가지고 있기 떄문입니다.

<br>

> 📕 **1. 작업을 하위작업으로 나누기 (지연 시간을 최적화 할 때와 같은 단점)**

- 작업을 여러개로 나누고, 나눈 작업을 스케줄링
- 완료한 각각의 작업을 다시 결합
- 이떄 컨텍스트 스위칭 등 리소스 비용 발생
- 무엇보다 처리량에 있어서 이 행동은 완전히 불필요한 행동임

<br>

> 📕 **2. 각 작업을 별개의 스레드에 스케쥴링 (병렬 실행)**

- 이 경우도 이론적으로 최대 처리량은 N/T 가 됨
- 이 접근법에서는 각 작업을 작은 Task로 나눠야 하는 전처리 과정이 필요 없음
- 작업은 각각 하나의 결과만 갖기 때문에, 작업의 포스트 프로세싱이 필요 없음
- 또, 완전히 별개의 작업이기 때문에 다른 작업의 완료를 위해 현재 작업이 Blocking 될 필요가 없음
- Thread-Pooling이나 Non-Blocking Queue 같은 기술의 의존 없이 최적의 처리량 달성 가능

---

## 📘 Thread Pooling

Thread Pooling은 Thread를 생성하고 나중의 작업을 위해 Thread를 다시 사용합니다.

매번 처음부터 다시 Thread를 생성하지 않아도 되는 이점이 있습니다.

Thread가 생성되면 Pool에 쌓이고, 작업이 대기열을 통해 스레드별로 분배되어 실행됩니다.

<br>

Runnable이 가능한 스레드는 대기열을 통해 작업을 할당 받습니다.

**만약 모든 스레드가 Runnable 상태이면 대기열에서 대기하며, 작업중인 스레드가 Runnable 상태가 될 떄까지 대기합니다.**

<br>

스레드를 바쁘게 사용하여, 작업들이 대기열에 쌓이게 되면 **최대 처리량 / 리소스의 최대 사용률**을 얻을 수 있습니다.

<br>

> 📕 **Thread Pool 구현**

- **낮은 오버헤드와 효율적인 대기열을 구현**할 수 있습니다.
- JDK에서 지원하는 Fixed Thread Pool Executor를 사용 할 수 있습니다.
- 파라미터에 Pool에 존재할 스레드의 수를 지정항 생성합니다.

```java
// 스레드 풀 생성
Executor executor = Executores.newFixedThreadPool(5);

// 스레드 실행
Runnable task = ...;
executor.execute(task);
```

<br>

> 📕 **결론**

2번쨰 접근법인 **각 작업을 별개의 스레드에 스케쥴링** 방법을 사용합니다.

각 작업은 독립적으로 실행되며 성능을 N(스레드/코어 수)으로 개선할 수 있습니다.

또, 스레드 풀을 이용해 일정 수의 스레드를 낮은 오버헤드로 유지시킬 수 있으며, 작업 시마다 스레드를 생성할 필요가 없습니다.

