## Hash Table

키 값을 기반으로 데이터의 저장 위치를 **상수 시간**내에 직접 계산하여 저장, 삭제, 탐색하는 방법

키 값은 **해시 함수**를 통해 해시 테이블의 주소로 변환됩니다.

그리고, 해시 함수를 통해 위치가 매핑된 주소가 같을경우 **해시 충돌**이라고 부릅니다.

<br>

보통 키 값이 정수일떄 **제산 잔여법, 중간 제곱법, 비닝** 방법을, 문자열일 때 **비닝, 단순 합, 가중 합** 등의 방법을 사용합니다.

다양한 해싱 방법 중 **해시 충돌이 적고, 계산이 용이한 함수를 사용**하는것이 바람직합니다.

---
## 해시 함수: 제산 잔여법

제산 잔여법은 `%` 연산을 이용해 키를 해시 테이블의 크기로 나눈 나머지를 해시 주소로 사용하는 방법입니다.

`h(k) = K mod M` (K: 키값, M: 해시 테이블의 크기)

<br>

이 방법을 사용할 떄 주의할 점은 **해시 테이블의 크기(M)의 선택에 주의해야 합니다.**

- M=2^r 이라고 가정했을떄 h(k)는 키 값의 하위 r비트의 값이 됩니다.
- 즉, 키 값의 전체 비트가 주소 계산에 활용되지 못합니다.
- 예를 들면 키 값이 39, 3751 두 값의 2진수중 첫 4비트만 사용되어 둘다 7이라는 주소값을 가지며 해시 충돌이 일어납니다.
- 그래서 보통 2의 거듭 제곱과 상당한 차이가 있는 **소수**로 선택하는 것이 바람직합니다.

---
## 해시 함수: 비닝 (정수)

키의 집합을 해시테이블 만큼 나누어 각 나눈 만큼을 각 슬롯으로 해싱하는 방법입니다.

키 값의 범위 : U (0~999) / 해시 테이블의 크기 : M (10) 라고 가정해보면, 각 슬롯당 100개의 키를 가지게 됩니다.

이 방법의 단점으로는 상위 비트의 분포가 고르지 못하면, 특정 슬롯에 값이 집중되는 문제가 있습니다.

---
## 해시 함수: 비닝 (문자열)

문자열의 앞쪽 일부를 해시 결과로 사용하는 함수입니다.

입력 문자열의 앞쪽 분포가 고르지 못할 때, 결과가 슬롯에 고르게 분포되지 못하는 단점이 있습니다.

<br>

> **예시**

- 영어 대문자로 구성된 문자열인 키값  `x[]`를 26개의 슬롯으로 해싱하는 함수
- 문자열의 첫 글자를 기반으로 슬롯 할당이 됩니다.

```c
h (int x[]) {
	return (x[0] - 'A');
}
```

---
## 해시 함수: 중간 제곱법

키를 제곱한 후, 중간의 몇 비트를 해시 주소로 생성하는 해시 함수입니다.

<br>

`h(k) = (k^2 / 2^m) mod 2^r`

- m : 키값을 제곱한 결과에서 사용하지 않을 하위 비트의 크기
- r : 해시 주소로 취할 비트의 크기

<br>

> **예시**

- 키값 : 3자리 10진수 (123)
- 해시 테이블의 크기 : 16 (r = 4)
- m : 7

```c
h (int x) {
	return (x * x / 128) % 16;
}
```

1. 주어진 키 값 제곱 : `123^2 = 15129 -> 11 1011 0001 1001`
2. 제곱한 값에 2^7인 128을 나눈다는 의미는 첫 7비트를 버린다는 의미입니다. -> `11 1011 0`**001 1011**
3. 그럼 `123^2`의 원래 비트가 `111 0110` 으로 바뀌게 됩니다.
4. 그리고 16으로 나머지 연산을 합니다. `(16 = 2^4)` -> 2의 4제곱 이니 첫 4비트를 사용하겠다는 의미입니다.
5. 그럼 주소값은 `0100 (6)`으로  6번째 슬롯에 123이라는 상수 키 값을 해싱하여 넣게 됩니다.

<br>

위 예시 처럼 중간 제곱법은 모든/대부분의 비트가 해싱 결과에 기여하므로,

상위/하위 자리의 분포에 의해 지배적인 영향을 받지 않는 함수입니다.

---
## 해시 함수: 단순 합 (문자열)

각 문자의 코드 값을 합한 후 제산 잔여법을 적용하는 함수입니다.

