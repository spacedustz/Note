## 탐색의 종류

여러개의 원소로 구성된 데이터에서 원하는 값을 갖는 원소를 찾는것

- 데이터의 형태 : 리스트, 트리, 그래프 등
- 내부탐색과 외부탐색 존재
- 관련 연산 : 탐색 + (초기화, 삽입, 삭제)

> 탐색 방법

- 리스트 형태 -> 순차 탐색, 이진 탐색
- 트리 형태 -> 이진 탐색 트리, 2-3-4 트리, 레드-블랙 트리, B-트리
- 해시 테이블 -> 해시 함수, 해시 충돌 해결

---

## 순차 탐색 / O(n)

리스트 형태로 주어진 원소들을 처음부터 하나씩 차례로 "순차" 비교하면서 원하는 값을 갖는 원소 탐색

**정렬되지 않고, 크기가 작은 데이터셋에 적합합니다.**

<br>

### 순차 탐색 기본 예시 코드

**입력**

- `A[0..n-1]` -> 입력 배열
- `n` -> 입력 크기(탐색할 데이터의 개수)
- `x` -> 탐색 키

<br>

**출력**

- x가 배열 내에 존재하면 index 반환, 아니면 n 반환

```c
SequentialSearch(A[], n, x) {
    i=0;
    while (i<n && A[i] != x)
        i = i+1
        
    return (i);
}
```

<br>

### 순차 탐색 - 삽입 / O(1)

배열의 맨끝에 그냥 단순히 원소를 추가합니다.

- `A[0..n-1]` -> 입력 배열
- `n` -> 입력 크기
- `x` -> 삽입할 원소

```c
SequentialSearch_Insert(A[], n, x) {
    A[n] = x;
    return (A, n+1);
}
```

<br>

### 순차 탐색 - 삭제 / O(n)

제거할 대상을 먼저 순차 탐색으로 찾고, 배열의 맨 마지막 데이터를 제거할 원소의 자리에 위치시켜 제거

```c
SequentialSearch_Delete(A[], n, x) {
    index = SequentialSearch (A, n, x);
    if (index == -1) return (A, n);
    A[index] = A[n-1];
    return (A, n-1);
}
```