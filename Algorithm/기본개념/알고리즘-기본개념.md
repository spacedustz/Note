## Greedy 알고리즘

> **배낭 문제**

- 최대용량이 `M`인 내앙에 `N`개의 물체가 있다고 가정
- 각 물체 `I`에는 물체의 무게 `W`와 해당 물체를 넣었을떄 얻을수 있는 이익 `P`가 부여됨
- 물체는 쪼개서 넣을 수 있음
- **물체를 쪼갤수 없을때는 Greedy로 풀 수 없다**

<br>

> **기본 해결 방안**

- `단위 무게당 이익`이 가장 큰 물체부터 최대한 넣는 과정을 반복
- 물체를 통째로 넣지 못하면 남은 용량에 맞게 물체를 쪼개서 넣음

<br>

> **에시 문제**

- M = 10
- N = 4
- P1, P2, P3 P4 = 15, 20, 9 ,14
- W1, W2, W3, W4 = 3, 5 , 3, 4

<br>

**단위 무게당 이익 계산**

- 15 / 3
- 20 / 5
- 9 / 3
- 14 / 4
- **단위 무게당 이익 : 5, 4, 3, 3.5**
- 1,2,4,3 순으로 단위 무게 당 이익이 크다.

---
## 분할 정복 알고리즘

**순환적으로 문제를 푸는 하향식(Top-Down) 접근 방법**

- 주어진 문제의 입력을 더 이상 나눌 수 없을 때 까지 2개 이상의 작은 문제들로 순환적으로 분할
- 분할된 작은 문제들을 각각 해결 후 이들의 해를 결합하여 원래 문제의 해를 구하는 방식

<br>

> **특징**

- 분할된 작은 문제는 원래 문제와 동일하고, 입력의 크기만 작아진 문제이다.
- 분할된 문제는 독립적이며, 각 문제의 결과를 결합 가능하다.
- 대표적인 적용 사례로는 **퀵 정렬, 합병 정렬, 이진 탐색**이 있다.

<br>

> **이진 탐색 예시**

`10 ,15, 20, 25, 30 ,35 ,40, 45, 50` 총 길이가 9인 배열에서 20을 찾는 문제

- 배열은 정렬되어 있다고 가정한다.
- 우선 배열을 절반으로 나눈다. {0,1,2,3}   {5,6,7,8}
- 위 분할 배열에서 빠진 가운데 원소인 4번 인덱스가 20과 일치하는지, 4번 인덱스의 숫자가 20보다 큰지 검증
- 일치하면 함수 종료, 20이 인덱스 4번의 숫자보다 작으면 오른쪽 배열 버림
- 반복

---
## 동적 프로그래밍

**입력의 크기가 가장 작은 부분**부터 해를 구해 테이블에 저장해 놓고,

이를 이용해 **입력 크기가 보다 큰 문제**의 해를 점진적으로 만들어가는 상향식 접근 방법(Bottom-Up)

<br>

> **특징**

- 각각의 작은 문제는 원래 문제와 동일하며, 입력의 크기만 작다
- 분할 정복과는 다르게, 작은 문제들은 서로 독립적일 필요가 없다

<br>

> **동적 프로그래밍을 적용한 대표 사례**

- 모든 정점 쌍 간의 최단 경로 -> 플로이드 알고리즘
- 행렬의 연쇄적 곱셈 문제
- 최장 공통 부분 수열 문제
- 등등

---
## 점근성능과 결정 방법

입력 크기가 무한히 커짐에 따라 결정되는 성능 -> 최고차수만으로 간략히 표현

- 입력 크기가 충분히 커짐에 따라 함수값에 가장 큰 영향을 미치는 차수를 찾음
- 수행시간의 다항식 함수에서 **최고차항**만을 **계수 없이** 취해서 표현
- 예를 들어 촤고차항이 2n^2이면 점근성능의 결과값은 n^2 이며 O(n^2) 으로 표현
- 이 결과값은 수행시간의 정확한 값이 아닌, 어림값이며, 수행시간의 증가 추세를 파악하기 쉽다.

`O(1)` < `O(logN)` < `O(n)` < `O(NlogN)` < `O(n^2)` < `O(n^3)` < `O(2n)`

---
## 순환 알고리즘 (Recursion)

- 이진 탐색과 유사하게 가운데 부분을 나누고 가운데가 맞지 않으면 왼쪽, 오른쪽에 재귀 호출

```c
BinarySearch(A[], key, Left, Right) {
	if (Left > Right) return (-1);
	mid = [(Left + Right)] / 2;

	if (A[mid] == key) return (Mid); // 성공
	else if (key < A[mid]) BinarySearch(A, key, Left, mid-1)
	else BinarySearch(A, key, mid+1, Right)
}
```

<br>
### 시간복잡도의 점화식과 폐쇄형

순환 알고리즘의 수행 시간은 점화식 형태로 정의되며, 폐쇄형을 구해서 표현한다.

또한 분할정복 방법이 적용된 알고리즘은 기본적으로 순환 알고리즘의 형태를 가짐.

① T(n) = T(n-1) + Θ(1), T(1)=Θ(1) → T(n) = Θ(n)  

② T(n) = T(n-1) + Θ(n), T(1)=Θ(1) → T(n) = Θ(n2) → 퀵 정렬의 최악 수행 시간  

③ T(n) = T(n/2) + Θ(1), T(1)=Θ(1) → T(n) = Θ(logn) → 이진 탐색의 수행 시간  

④ T(n) = T(n/2) + Θ(n), T(1)=Θ(1) → T(n) = Θ(n)  

⑤ T(n) = 2T(n/2) + Θ(1), T(1)=Θ(1) → T(n) = Θ(n)  

⑥ T(n) = 2T(n/2) + Θ(n), T(1)=Θ(1) → T(n) = Θ(nlogn) → 퀵 정렬의 최선 수행 시간, 합병 정렬의 수행 시간

![](./1.png)